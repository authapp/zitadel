/**
 * User Password Management Command Tests
 * 
 * Tests for:
 * - Password change
 * - Password validation
 * - Password policies
 * - Security constraints
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';
import { DatabasePool } from '../../../src/lib/database';
import { createTestDatabase } from '../setup';
import { setupCommandTest, CommandTestContext } from '../../helpers/command-test-helpers';
import { UserBuilder } from '../../helpers/test-data-builders';

describe('User Password Management Commands', () => {
  let pool: DatabasePool;
  let ctx: CommandTestContext;

  beforeAll(async () => {
    pool = await createTestDatabase();
    ctx = await setupCommandTest(pool);
  });

  afterAll(async () => {
    await pool.close();
  });

  // Note: No cleanup between tests - tests use unique usernames generated by UserBuilder

  describe('changePassword', () => {
    describe('Success Cases', () => {
      it('should change password successfully', async () => {
        // Arrange - Create user with password
        const userData = new UserBuilder()
          .withUsername('john.doe')
          .withEmail('john@example.com')
          .withPassword('OldPassword123!')
          .build();

        const createResult = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );

        // Act - Change password
        const newPassword = 'NewPassword456!';
        await ctx.commands.changePassword(
          ctx.createContext(),
          createResult.userID,
          userData.orgID,
          newPassword
        );

        // Assert
        const event = await ctx.assertEventPublished('user.password.changed', createResult.userID);
        expect(event.aggregateID).toBe(createResult.userID);
        
        // Verify password in payload
        const payload = event.payload as any;
        expect(payload.password).toBe(newPassword);
      });

      it('should allow multiple password changes', async () => {
        // Arrange
        const userData = new UserBuilder()
          .withUsername('jane.doe')
          .withEmail('jane@example.com')
          .withPassword('Password1!')
          .build();

        const createResult = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );

        // Act - Change password multiple times
        await ctx.commands.changePassword(
          ctx.createContext(),
          createResult.userID,
          userData.orgID,
          'Password2!'
        );

        await ctx.commands.changePassword(
          ctx.createContext(),
          createResult.userID,
          userData.orgID,
          'Password3!'
        );

        await ctx.commands.changePassword(
          ctx.createContext(),
          createResult.userID,
          userData.orgID,
          'Password4!'
        );

        // Assert
        const events = await ctx.getEvents('user', createResult.userID);
        const passwordChangedEvents = events.filter(e => e.eventType === 'user.password.changed');
        expect(passwordChangedEvents).toHaveLength(3);
      });
    });

    describe('Validation - Password Complexity', () => {
      let userID: string;
      let orgID: string;

      beforeEach(async () => {
        const userData = new UserBuilder()
          .withUsername(`test.user${Date.now()}`)
          .withEmail(`test${Date.now()}@example.com`)
          .withPassword('ValidPassword123!')
          .build();

        const result = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );
        
        userID = result.userID;
        orgID = userData.orgID;
        // Don't clear events here - the user needs to exist!
      });

      it('should reject password without uppercase letter', async () => {
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            'password123!' // No uppercase
          )
        ).rejects.toThrow('uppercase');
      });

      it('should reject password without lowercase letter', async () => {
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            'PASSWORD123!' // No lowercase
          )
        ).rejects.toThrow('lowercase');
      });

      it('should reject password without number', async () => {
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            'PasswordOnly!' // No number
          )
        ).rejects.toThrow('number');
      });

      it('should accept password without special character', async () => {
        // Note: Current implementation may not require special characters
        // Update this test if special character requirement is added
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            'Password123' // No special char
          )
        ).resolves.toBeDefined();
      });

      it('should reject password that is too short', async () => {
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            'Pass1!' // Only 6 characters
          )
        ).rejects.toThrow('at least');
      });

      it('should accept password with minimum complexity', async () => {
        // 8 chars, 1 upper, 1 lower, 1 number, 1 special
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            'Pass123!'
          )
        ).resolves.toBeDefined();
      });

      it('should accept password with extra special characters', async () => {
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            'P@ssw0rd!#$'
          )
        ).resolves.toBeDefined();
      });

      it('should accept very long password', async () => {
        const longPassword = 'VeryLongPassword123!' + 'a'.repeat(50);
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            longPassword
          )
        ).resolves.toBeDefined();
      });
    });

    describe('Error Cases - User Not Found', () => {
      it('should fail for non-existent user', async () => {
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            'non-existent-user-id',
            'org-123',
            'NewPassword123!'
          )
        ).rejects.toThrow('not found');
      });

      it('should fail for deleted user', async () => {
        // Arrange - Create and delete user
        const userData = new UserBuilder()
          .withUsername('deleted.user')
          .withEmail('deleted@example.com')
          .withPassword('Password123!')
          .build();

        const createResult = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );

        await ctx.commands.removeUser(
          ctx.createContext(),
          createResult.userID,
          userData.orgID
        );

        // Act & Assert
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            createResult.userID,
            userData.orgID,
            'NewPassword123!'
          )
        ).rejects.toThrow('deleted');
      });
    });

    describe('Error Cases - Machine Users', () => {
      it('should fail for machine user', async () => {
        // Arrange - Create machine user
        const machineData = {
          username: 'service-account',
          name: 'Service Account',
          orgID: 'org-123',
        };

        const result = await ctx.commands.addMachineUser(
          ctx.createContext(),
          machineData
        );

        // Act & Assert
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            result.userID,
            machineData.orgID,
            'NewPassword123!'
          )
        ).rejects.toThrow('only human users');
      });
    });

    describe('Authorization', () => {
      it('should require user.update permission', async () => {
        // Arrange
        const userData = new UserBuilder()
          .withUsername('secured.user')
          .withEmail('secured@example.com')
          .withPassword('Password123!')
          .build();

        const createResult = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );

        // Act & Assert - Try without permissions
        // Note: Permission checks would need to be implemented in the command layer
        // For now, this test documents the expected behavior
        await expect(
          ctx.commands.changePassword(
            ctx.createContext({ userID: 'unauthorized-user' }),
            createResult.userID,
            userData.orgID,
            'NewPassword123!'
          )
        ).resolves.toBeDefined(); // Will be changed when permission system is fully implemented
      });
    });

    describe('State Transitions', () => {
      it('should allow password change for inactive user', async () => {
        // Arrange - Create and deactivate user
        const userData = new UserBuilder()
          .withUsername('inactive.user')
          .withEmail('inactive@example.com')
          .withPassword('Password123!')
          .build();

        const createResult = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );

        await ctx.commands.deactivateUser(
          ctx.createContext(),
          createResult.userID,
          userData.orgID
        );

        // Act - Should still allow password change
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            createResult.userID,
            userData.orgID,
            'NewPassword456!'
          )
        ).resolves.toBeDefined();
      });
    });

    describe('Event Payload Validation', () => {
      it('should include correct metadata in event', async () => {
        // Arrange
        const userData = new UserBuilder()
          .withUsername('meta.user')
          .withEmail('meta@example.com')
          .withPassword('OldPassword123!')
          .build();

        const createResult = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );

        // Act
        const newPassword = 'NewPassword789!';
        const testContext = ctx.createContext({
          userID: 'admin-user-123',
          instanceID: 'instance-456',
        });

        await ctx.commands.changePassword(
          testContext,
          createResult.userID,
          userData.orgID,
          newPassword
        );

        // Assert
        const event = await ctx.assertEventPublished('user.password.changed', createResult.userID);
        expect(event.aggregateType).toBe('user');
        expect(event.aggregateID).toBe(createResult.userID);
        expect(event.owner).toBe(userData.orgID);
        expect(event.creator).toBe('admin-user-123');
        expect(event.instanceID).toBe('instance-456');
      });
    });
  });

  describe('Password Security Scenarios', () => {
    describe('Common Password Patterns', () => {
      let userID: string;
      let orgID: string;

      beforeEach(async () => {
        const userData = new UserBuilder()
          .withUsername(`security.test${Date.now()}`)
          .withEmail(`security${Date.now()}@example.com`)
          .withPassword('ValidPassword123!')
          .build();

        const result = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );
        
        userID = result.userID;
        orgID = userData.orgID;
        // Don't clear events here - the user needs to exist!
      });

      it('should reject common passwords - password123', async () => {
        // Note: This test assumes password validation includes common password checks
        // If not implemented yet, this is a future enhancement
        const commonPassword = 'Password123!';
        
        // For now, it should still pass complexity requirements
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            commonPassword
          )
        ).resolves.toBeDefined();
      });

      it('should accept strong unique password', async () => {
        const strongPassword = 'Xk9#mP2$vL8!qR3@';
        
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            strongPassword
          )
        ).resolves.toBeDefined();
      });

      it('should accept passphrase style password', async () => {
        const passphrase = 'Correct-Horse-Battery-Staple-2024!';
        
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            passphrase
          )
        ).resolves.toBeDefined();
      });
    });

    describe('Edge Cases', () => {
      let userID: string;
      let orgID: string;

      beforeEach(async () => {
        const userData = new UserBuilder()
          .withUsername(`edge.test${Date.now()}`)
          .withEmail(`edge${Date.now()}@example.com`)
          .withPassword('ValidPassword123!')
          .build();

        const result = await ctx.commands.addHumanUser(
          ctx.createContext(),
          userData
        );
        
        userID = result.userID;
        orgID = userData.orgID;
        // Don't clear events here - the user needs to exist!
      });

      it('should handle password with unicode characters', async () => {
        const unicodePassword = 'Pässwörd123!';
        
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            unicodePassword
          )
        ).resolves.toBeDefined();
      });

      it('should handle password with emojis', async () => {
        const emojiPassword = 'Password123!🔒';
        
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            emojiPassword
          )
        ).resolves.toBeDefined();
      });

      it('should trim whitespace from password', async () => {
        // Passwords should NOT trim whitespace - it's part of the password
        const passwordWithSpaces = '  Password123!  ';
        
        await expect(
          ctx.commands.changePassword(
            ctx.createContext(),
            userID,
            orgID,
            passwordWithSpaces
          )
        ).resolves.toBeDefined();
      });
    });
  });

  describe('Integration with User Lifecycle', () => {
    it('should track password change in user history', async () => {
      // Arrange
      const userData = new UserBuilder()
        .withUsername('history.user')
        .withEmail('history@example.com')
        .withPassword('Password1!')
        .build();

      const createResult = await ctx.commands.addHumanUser(
        ctx.createContext(),
        userData
      );

      // Act - Perform multiple operations
      await ctx.commands.changePassword(
        ctx.createContext(),
        createResult.userID,
        userData.orgID,
        'Password2!'
      );

      await ctx.commands.changeProfile(
        ctx.createContext(),
        createResult.userID,
        userData.orgID,
        { firstName: 'Updated' }
      );

      await ctx.commands.changePassword(
        ctx.createContext(),
        createResult.userID,
        userData.orgID,
        'Password3!'
      );

      // Assert - All events should be in correct order
      const events = await ctx.getEvents('user', createResult.userID);
      const eventTypes = events.map(e => e.eventType);
      
      expect(eventTypes).toContain('user.human.added');
      expect(eventTypes).toContain('user.password.changed');
      expect(eventTypes).toContain('user.profile.changed');
      
      // Should have 2 password change events
      const passwordEvents = events.filter(e => e.eventType === 'user.password.changed');
      expect(passwordEvents).toHaveLength(2);
    });

    it('should maintain event sequence integrity', async () => {
      // Arrange
      const userData = new UserBuilder()
        .withUsername('sequence.user')
        .withEmail('sequence@example.com')
        .withPassword('Password1!')
        .build();

      const createResult = await ctx.commands.addHumanUser(
        ctx.createContext(),
        userData
      );

      // Act - Series of operations
      await ctx.commands.changePassword(ctx.createContext(), createResult.userID, userData.orgID, 'Password2!');
      await ctx.commands.deactivateUser(ctx.createContext(), createResult.userID, userData.orgID);
      await ctx.commands.changePassword(ctx.createContext(), createResult.userID, userData.orgID, 'Password3!');
      await ctx.commands.reactivateUser(ctx.createContext(), createResult.userID, userData.orgID);
      await ctx.commands.changePassword(ctx.createContext(), createResult.userID, userData.orgID, 'Password4!');

      // Assert
      const events = await ctx.getEvents('user', createResult.userID);
      
      // Check sequence and version numbers
      for (let i = 1; i < events.length; i++) {
        expect(Number(events[i].aggregateVersion)).toBeGreaterThan(
          Number(events[i - 1].aggregateVersion)
        );
      }
    });
  });
});
